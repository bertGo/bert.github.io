## DAY SIX (7/20)

### C

- C语言不做指针的安全检查
- `在指针上面加或减，其实是在做地址的偏移`  给指向地址的指针或地址加特定的值，返回的结果是根据内存地址去偏移特定的值然后指向新的地址；返回的数字或字符是新的地址对应的值
  -  int *p = &a
  -   ‘ *p=a  ;p[3]或者p+=3;都是在做指针偏移，代表在p所指向的内存偏移三个整型的量；  //p[4]=101 的含义是 p这个指针偏移四个(整型)量
  - array的本质也是一个指针的类型
    - array本质上是指针常量，array只要声明了，它就指向这个地址，而变量做成的指针是可以指向不同地址的量。
-  给一个指针赋值一个地址，相当于让指针去 寻找这个地址的值 ,如果在函数体i内，可以根据地址找到函数外的值
  - 与给一个变量赋值一个地址的区别是，这个变量所存储的地址发生了改变，如果在函数体内，只在函数内发生作用

- 静态局部变量：函数中局部变量的值在函数调用结束时不会消失，仍然保留其原值，即它所占用的存储单元不释放，在下一次调用该函数时，其局部变量的值仍然存在，用static 声明静态局部变量
- 静态全局变量：仅在本源文件中可以使用，其他源文件不能引用
- 32位指针占4个字节，64位占8个字节
- 函数指针，其本质是一个指针变量，该指针指向这个函数。函数指针是需要把一个函数的地址赋值给它，函数指针示例：int (*pre)(int a){}
- 指针函数是返回一个指针的函数，其本质是一个函数，返回值是一个指针
- C语言中，声明数组需要输入数组的长度 ：int array[2],其内必须是常量不可以是变量

### 计算机

- 32位
  - 指的是：给 内存编号只能编到32个二进制位 ，三十二根地址总线就有2的32次方个状态
  - 32位操作系统最多使用4G内存:
  - 1G内存：1024 * 1024 * 1024 *4字节 = 1024x1024x4k =1024 x 4M
- 64位
  - 可以使用的内存太多了-.-||
- 计算机操作系统会给所有的内存进行编号，每一个编号=唯一的内存字节的地址
  - 也给内存做一定的规划，64位系统中，后48位内存空间是给用户使用管理的，前16位是给操作系统内核使用的,用户的内存和操作
  -  系统的内存是隔离开的：哪怕是用户内存全部占满了，操作系统的内存也不会受影响，更加安全
- 从低位内存到高位内存：
  - 代码段：函数编译之后存到磁盘，代码编译后的二进制数据加载到内存中，以及计算机指令都会放在代码段，在代码段内，先声明的代码段地址小，后声明的大，是由`低位到高位`的
  - 数据段：声明一些全局变量和常量还有静态变量都会存放在数据段
  - 堆内存： 
  - 自由可分配内存：---
  - 栈内存：保存函数当前执行 的状态，包括代码执行到多少行指令，每个内存空间内到底是 什么数据什么数值，每个栈并不会关心函数和变量 的名称：因为每一个函数都会被多次调用，每次调用函数都是一个独立的栈,先声明的内存地址大，后声明的小，是由高位到低位的
    - 栈的特点是先进后出，后进先出 
    - 个人 理解 ：为了与系统内核分隔开，不误用系统内核的空间
  - 系统内核: 
- 变量的本质 ：变量名只是一个代号，变量的本质 就是一个内存
- 指针保存的就是内存的地址，指针本质就是地址
  - 一级指针保存的是一个变量的地址，二级指针保存的是一个指针地址，这个指针的地址指向另外 一个变量的地址
- 连续赋值后，内存不连续的情况：存在编译器的优化功能，编译器在编译源代码时，为了能让我们cpu操作指令更方便，会对源代码进行一定的优化，所以编译之后的存储和我们编写的存储有可能会不一样；

### GDB

- p 加地址符 可以打印函数所在内存位置和变量所在内存位置
- p加 * 就是访问指针指向的地址，不加 * 就是访问本身的地址

